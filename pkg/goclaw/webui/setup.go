package webui

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"
)

// SetupRequest contains all data from the setup wizard frontend.
type SetupRequest struct {
	Name          string          `json:"name"`
	Language      string          `json:"language"`
	Timezone      string          `json:"timezone"`
	Provider      string          `json:"provider"`
	APIKey        string          `json:"apiKey"`
	Model         string          `json:"model"`
	WebuiPassword string          `json:"webuiPassword"`
	AccessMode    string          `json:"accessMode"`
	Channels      map[string]bool `json:"channels"`
	EnabledSkills []string        `json:"enabledSkills"`
}

// handleAPISetup routes setup-related requests.
func (s *Server) handleAPISetup(w http.ResponseWriter, r *http.Request) {
	path := strings.TrimPrefix(r.URL.Path, "/api/setup/")

	switch path {
	case "status":
		s.handleSetupStatus(w, r)
	case "test-provider":
		s.handleSetupTestProvider(w, r)
	case "finalize":
		s.handleSetupFinalize(w, r)
	default:
		writeJSON(w, http.StatusNotFound, map[string]string{"error": "not found"})
	}
}

// handleSetupStatus reports whether the system is already configured.
func (s *Server) handleSetupStatus(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		writeJSON(w, http.StatusMethodNotAllowed, map[string]string{"error": "method not allowed"})
		return
	}

	configured := configFileExists()
	writeJSON(w, http.StatusOK, map[string]any{
		"configured":   configured,
		"current_step": 0,
	})
}

// handleSetupTestProvider makes a real API call to verify provider credentials.
func (s *Server) handleSetupTestProvider(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		writeJSON(w, http.StatusMethodNotAllowed, map[string]string{"error": "method not allowed"})
		return
	}

	var body struct {
		Provider string `json:"provider"`
		APIKey   string `json:"api_key"`
		Model    string `json:"model"`
	}
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "invalid request"})
		return
	}

	if body.Model == "" {
		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "model is required"})
		return
	}

	baseURL := providerBaseURL(body.Provider)
	if err := testProviderConnection(baseURL, body.APIKey, body.Model); err != nil {
		s.logger.Debug("provider test failed", "provider", body.Provider, "error", err)
		writeJSON(w, http.StatusOK, map[string]any{
			"success": false,
			"error":   err.Error(),
		})
		return
	}

	writeJSON(w, http.StatusOK, map[string]any{"success": true})
}

// handleSetupFinalize generates config.yaml and .env from wizard data.
func (s *Server) handleSetupFinalize(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		writeJSON(w, http.StatusMethodNotAllowed, map[string]string{"error": "method not allowed"})
		return
	}

	var setup SetupRequest
	if err := json.NewDecoder(r.Body).Decode(&setup); err != nil {
		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "invalid request body"})
		return
	}

	if setup.Name == "" {
		setup.Name = "GoClaw"
	}
	if setup.Model == "" {
		writeJSON(w, http.StatusBadRequest, map[string]string{"error": "model is required"})
		return
	}

	// Safety: don't overwrite an existing config unless in setup mode.
	if configFileExists() && !s.setupMode {
		writeJSON(w, http.StatusConflict, map[string]string{"error": "config.yaml already exists — use /api/config to modify"})
		return
	}

	// Generate and write config.yaml.
	configYAML := generateConfigYAML(&setup)
	if err := os.WriteFile("config.yaml", []byte(configYAML), 0o600); err != nil {
		s.logger.Error("failed to write config.yaml", "error", err)
		writeJSON(w, http.StatusInternalServerError, map[string]string{"error": "failed to write config: " + err.Error()})
		return
	}
	s.logger.Info("config.yaml written by setup wizard")

	// Write API key to .env (never hardcode secrets in config).
	if setup.APIKey != "" {
		envContent := "# GoClaw — generated by setup wizard\nGOCLAW_API_KEY=" + setup.APIKey + "\n"
		if err := os.WriteFile(".env", []byte(envContent), 0o600); err != nil {
			s.logger.Error("failed to write .env", "error", err)
		}
	}

	// Create data directories.
	for _, dir := range []string{"./data", "./sessions/whatsapp", "./plugins"} {
		os.MkdirAll(dir, 0o755)
	}

	// Signal setup completion (for setup-only mode).
	if s.onSetupDone != nil {
		go s.onSetupDone()
	}

	writeJSON(w, http.StatusOK, map[string]any{
		"status":  "ok",
		"message": "Configuração salva. Reinicie o servidor para aplicar.",
	})
}

// ── Provider helpers ──

// providerBaseURL returns the API base URL for known providers.
func providerBaseURL(provider string) string {
	switch strings.ToLower(provider) {
	case "openai":
		return "https://api.openai.com/v1"
	case "anthropic":
		return "https://api.anthropic.com/v1"
	case "openrouter":
		return "https://openrouter.ai/api/v1"
	case "ollama":
		return "http://localhost:11434/v1"
	default:
		return "https://api.openai.com/v1"
	}
}

// testProviderConnection makes a minimal chat completion request to verify credentials.
func testProviderConnection(baseURL, apiKey, model string) error {
	payload := map[string]any{
		"model": model,
		"messages": []map[string]string{
			{"role": "user", "content": "Hi"},
		},
		"max_tokens": 5,
	}
	jsonBody, _ := json.Marshal(payload)

	req, err := http.NewRequest("POST", baseURL+"/chat/completions", bytes.NewReader(jsonBody))
	if err != nil {
		return fmt.Errorf("falha ao criar request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	if apiKey != "" {
		req.Header.Set("Authorization", "Bearer "+apiKey)
	}

	client := &http.Client{Timeout: 20 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("conexão falhou: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusOK {
		return nil
	}

	body, _ := io.ReadAll(io.LimitReader(resp.Body, 512))

	switch resp.StatusCode {
	case 401:
		return fmt.Errorf("API key inválida")
	case 403:
		return fmt.Errorf("acesso negado — verifique as permissões da key")
	case 404:
		return fmt.Errorf("modelo '%s' não encontrado", model)
	case 429:
		return fmt.Errorf("rate limit excedido — tente novamente em alguns segundos")
	default:
		msg := strings.TrimSpace(string(body))
		if msg == "" {
			msg = resp.Status
		}
		return fmt.Errorf("API retornou %d: %s", resp.StatusCode, msg)
	}
}

// configFileExists checks if a config file exists at common paths.
func configFileExists() bool {
	candidates := []string{
		"config.yaml", "config.yml",
		"copilot.yaml", "copilot.yml",
		"configs/config.yaml", "configs/copilot.yaml",
	}
	for _, path := range candidates {
		if _, err := os.Stat(path); err == nil {
			return true
		}
	}
	return false
}

// generateConfigYAML builds a config.yaml from the wizard data.
func generateConfigYAML(s *SetupRequest) string {
	var b strings.Builder

	b.WriteString("# GoClaw Copilot — generated by setup wizard\n")
	b.WriteString("# See configs/copilot.example.yaml for full reference.\n\n")

	// ── Assistant ──
	b.WriteString("# ── Assistant ──\n")
	fmt.Fprintf(&b, "name: %q\n", s.Name)
	fmt.Fprintf(&b, "trigger: \"@%s\"\n", strings.ToLower(strings.ReplaceAll(s.Name, " ", "")))
	fmt.Fprintf(&b, "model: %q\n", s.Model)
	fmt.Fprintf(&b, "timezone: %q\n", s.Timezone)
	fmt.Fprintf(&b, "language: %q\n", s.Language)
	b.WriteString("instructions: |\n")
	b.WriteString("  You are a helpful personal assistant.\n")
	b.WriteString("  Be concise and practical in your responses.\n\n")

	// ── API ──
	b.WriteString("# ── API Provider ──\n")
	b.WriteString("api:\n")
	fmt.Fprintf(&b, "  base_url: %q\n", providerBaseURL(s.Provider))
	b.WriteString("  api_key: \"${GOCLAW_API_KEY}\"\n")
	if s.Provider != "" && s.Provider != "custom" {
		fmt.Fprintf(&b, "  provider: %q\n", s.Provider)
	}
	b.WriteString("\n")

	// ── Access ──
	b.WriteString("# ── Access Control ──\n")
	b.WriteString("access:\n")
	switch s.AccessMode {
	case "relaxed":
		b.WriteString("  default_policy: allow\n")
	default:
		b.WriteString("  default_policy: deny\n")
	}
	b.WriteString("  owners: []\n\n")

	// ── Channels ──
	b.WriteString("# ── Channels ──\n")
	b.WriteString("channels:\n")
	if s.Channels["whatsapp"] {
		b.WriteString("  whatsapp:\n")
		b.WriteString("    session_dir: \"./sessions/whatsapp\"\n")
		fmt.Fprintf(&b, "    trigger: \"@%s\"\n", strings.ToLower(strings.ReplaceAll(s.Name, " ", "")))
		b.WriteString("    respond_to_groups: true\n")
		b.WriteString("    respond_to_dms: true\n")
		b.WriteString("    auto_read: true\n")
		b.WriteString("    send_typing: true\n")
		b.WriteString("    media_dir: \"./data/media\"\n")
	}
	if s.Channels["telegram"] {
		b.WriteString("  telegram:\n")
		b.WriteString("    token: \"${TELEGRAM_BOT_TOKEN}\"\n")
		b.WriteString("    respond_to_groups: true\n")
		b.WriteString("    respond_to_dms: true\n")
	}
	if s.Channels["discord"] {
		b.WriteString("  discord:\n")
		b.WriteString("    token: \"${DISCORD_BOT_TOKEN}\"\n")
		b.WriteString("    respond_to_dms: true\n")
	}
	if s.Channels["slack"] {
		b.WriteString("  slack:\n")
		b.WriteString("    bot_token: \"${SLACK_BOT_TOKEN}\"\n")
		b.WriteString("    app_token: \"${SLACK_APP_TOKEN}\"\n")
	}
	b.WriteString("\n")

	// ── Memory ──
	b.WriteString("# ── Memory ──\n")
	b.WriteString("memory:\n")
	b.WriteString("  type: sqlite\n")
	b.WriteString("  path: \"./data/memory.db\"\n")
	b.WriteString("  max_messages: 100\n\n")

	// ── Security ──
	b.WriteString("# ── Security ──\n")
	b.WriteString("security:\n")
	b.WriteString("  max_input_length: 4096\n")
	b.WriteString("  rate_limit: 30\n\n")

	// ── Skills ──
	b.WriteString("# ── Skills ──\n")
	b.WriteString("skills:\n")
	if len(s.EnabledSkills) > 0 {
		builtinSet := map[string]bool{
			"weather": true, "calculator": true, "web-search": true,
			"web-fetch": true, "memory": true,
		}
		var builtins, installed []string
		for _, sk := range s.EnabledSkills {
			if builtinSet[sk] {
				builtins = append(builtins, sk)
			} else {
				installed = append(installed, sk)
			}
		}
		if len(builtins) > 0 {
			fmt.Fprintf(&b, "  builtin: [%s]\n", strings.Join(builtins, ", "))
		} else {
			b.WriteString("  builtin: [weather, calculator, web-search]\n")
		}
		if len(installed) > 0 {
			fmt.Fprintf(&b, "  installed: [%s]\n", strings.Join(installed, ", "))
		}
	} else {
		b.WriteString("  builtin: [weather, calculator, web-search]\n")
	}
	b.WriteString("\n")

	// ── Scheduler ──
	b.WriteString("# ── Scheduler ──\n")
	b.WriteString("scheduler:\n")
	b.WriteString("  enabled: true\n")
	b.WriteString("  storage: \"./data/scheduler.db\"\n\n")

	// ── WebUI ──
	b.WriteString("# ── Web UI ──\n")
	b.WriteString("webui:\n")
	b.WriteString("  enabled: true\n")
	b.WriteString("  address: \":8090\"\n")
	if s.WebuiPassword != "" {
		fmt.Fprintf(&b, "  auth_token: %q\n", s.WebuiPassword)
	}
	b.WriteString("\n")

	// ── Logging ──
	b.WriteString("# ── Logging ──\n")
	b.WriteString("logging:\n")
	b.WriteString("  level: info\n")
	b.WriteString("  format: json\n")

	return b.String()
}
